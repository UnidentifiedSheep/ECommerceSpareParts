using Core.StaticFunctions;
using IntervalMap.Enums;
using IntervalMap.IntervalVariations;
using IntervalMap.Models;
using Microsoft.EntityFrameworkCore;
using MonoliteUnicorn.PostGres.Main;
using MonoliteUnicorn.Services.Prices.PriceGenerator.Models;
using Convert = System.Convert;

namespace MonoliteUnicorn.Services.Prices.PriceGenerator;

public static class SetupPriceGenerator
{
    private static DContext _context = null!;
    public static bool IsSetUpped { get; private set; } = false;
    public static readonly SettingsModel Settings = new SettingsModel();
    public static async Task SetupPricesAsync(IServiceProvider serviceProvider, DContext? givenContext = null, CancellationToken cancellationToken = default)
    {
        using var scope = serviceProvider.CreateScope();
        _context = givenContext ?? scope.ServiceProvider.GetRequiredService<DContext>();
        
        await GetDefaultSettingsAsync(cancellationToken);
        await SetToUsdAsync(cancellationToken);
        await SetMarkupsAsync(cancellationToken);
        IsSetUpped = true;
    }
    private static async Task GetDefaultSettingsAsync(CancellationToken cancellationToken = default)
    {
        var keyValuePairs = await _context.DefaultSettings.AsNoTracking()
            .ToDictionaryAsync(x => x.Key, z => z.Value, cancellationToken);
        Settings.SetupValuesViaNames(keyValuePairs);
    }

    private static async Task SetToUsdAsync(CancellationToken cancellationToken = default)
    {
        var toUsdDict = await _context.CurrencyToUsds.AsNoTracking()
            .ToDictionaryAsync(x => x.CurrencyId, cancellationToken);
        foreach (var value in toUsdDict)
            PriceGenerator.ToUsd.Add(value.Key, value.Value.ToUsd);
    }

    private static async Task SetMarkupsAsync(CancellationToken cancellationToken = default)
    {
        if(Settings.UseGeneratedMarkUp)
            await SetGeneratedMarkupsAsync(cancellationToken);
        await SetUserMarkupsAsync(cancellationToken);
    }

    private static async Task SetGeneratedMarkupsAsync(CancellationToken cancellationToken = default)
    {
        var generatedMarkup = await _context.MarkupGroups.AsNoTracking()
            .Include(x => x.MarkupRanges)
            .Where(x => x.IsAutoGenerated)
            .OrderBy(x => x.Id)
            .LastOrDefaultAsync(cancellationToken);
        if (generatedMarkup == null) return;
        foreach (var toUsd in PriceGenerator.ToUsd)
        {
            var newInterval = new AdaptiveIntervalMap<MarkupModel>(intersection: Intersection.CanIntersect);
            double lastRangeEnd = double.NaN;
            foreach (var markup in generatedMarkup.MarkupRanges.OrderBy(x => x.RangeStart))
            {
                var rangeStart = double.IsNaN(lastRangeEnd)
                    ? Math.Round(Convert.ToDouble(markup.RangeStart), 2)
                    : Math.Round(lastRangeEnd + 0.01, 2);
                var exchangedValue = markup.RangeEnd / PriceGenerator.ToUsd[generatedMarkup.CurrencyId] * toUsd.Value;
                var rangeEnd = (double)Math.Round(exchangedValue, 2);
                var markupModel = new MarkupModel(Math.Round(Convert.ToDouble(markup.Markup), 2));
                newInterval.AddInterval(new Interval<MarkupModel>(rangeStart, rangeEnd, markupModel));
                lastRangeEnd = rangeEnd;
            }
            PriceGenerator.MarkUps.Add(toUsd.Key, newInterval);
        }
        GC.Collect();
    }

    private static async Task SetUserMarkupsAsync(CancellationToken cancellationToken = default)
    {
        
    }
}
