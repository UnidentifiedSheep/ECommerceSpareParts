using Core.StaticFunctions;
using IntervalMap.Enums;
using IntervalMap.IntervalVariations;
using IntervalMap.Models;
using Microsoft.EntityFrameworkCore;
using MonoliteUnicorn.PostGres.Main;
using MonoliteUnicorn.Services.Prices.PriceGenerator.Models;
using Convert = System.Convert;

namespace MonoliteUnicorn.Services.Prices.PriceGenerator;

public static class SetupPriceGenerator
{
    private static DContext _context = null!;
    public static readonly SettingsModel Settings = new SettingsModel();
    public static async Task SetupPricesAsync(IServiceProvider serviceProvider, DContext? givenContext = null, CancellationToken cancellationToken = default)
    {
        using var scope = serviceProvider.CreateScope();
        _context = givenContext ?? scope.ServiceProvider.GetRequiredService<DContext>();

        await CreateDefaultSettingsIfNotExist(cancellationToken);
        await GetDefaultSettingsAsync(cancellationToken);
        await SetToUsdAsync(cancellationToken);
        await SetMarkupsAsync(_context, cancellationToken);
    }

    private static async Task CreateDefaultSettingsIfNotExist(CancellationToken cancellationToken = default)
    {
        var query = """
                    INSERT INTO default_settings ("key", "value")
                    VALUES 
                        ('DefaultCurrency', '3'), 
                        ('DefaultMarkUp', '50'),
                        ('MaximumDaysOfPriceStorage', '30'), 
                        ('SelectedMarkupId', '-1')
                    ON CONFLICT ("key") DO NOTHING;
                    """;
        await _context.Database.ExecuteSqlRawAsync(query, cancellationToken);
    }

    private static async Task GetDefaultSettingsAsync(CancellationToken cancellationToken = default)
    {
        var keyValuePairs = await _context.DefaultSettings.AsNoTracking()
            .ToDictionaryAsync(x => x.Key, z => z.Value, cancellationToken);
        Settings.SetupValuesViaNames(keyValuePairs);
    }

    private static async Task SetToUsdAsync(CancellationToken cancellationToken = default)
    {
        var toUsdDict = await _context.CurrencyToUsds.AsNoTracking()
            .ToDictionaryAsync(x => x.CurrencyId, x => x.ToUsd, cancellationToken);
        CurrencyConverter.LoadRates(toUsdDict);
    }

    public static async Task SetMarkupsAsync(DContext context, CancellationToken cancellationToken = default)
    {
        if(Settings.SelectedMarkupId == -1)
            await SetGeneratedMarkupsAsync(context, cancellationToken);
        await SetUserMarkupsAsync(context, cancellationToken);
    }

    private static async Task SetGeneratedMarkupsAsync(DContext context, CancellationToken cancellationToken = default)
    {
        var generatedMarkup = await context.MarkupGroups.AsNoTracking()
            .Include(x => x.MarkupRanges)
            .Where(x => x.IsAutoGenerated)
            .OrderBy(x => x.Id)
            .LastOrDefaultAsync(cancellationToken);

        if (generatedMarkup == null) return;

        BuildPriceGeneratorMarkupsAsync(generatedMarkup);
    }

    private static async Task SetUserMarkupsAsync(DContext context, CancellationToken cancellationToken = default)
    {
        var selectedMarkupId = int.Parse((await context.DefaultSettings
            .AsNoTracking()
            .FirstAsync(x => x.Key == "SelectedMarkupId", cancellationToken)).Value);

        var selectedMarkup = await context.MarkupGroups.AsNoTracking()
            .Include(x => x.MarkupRanges)
            .FirstOrDefaultAsync(x => x.Id == selectedMarkupId, cancellationToken);

        if (selectedMarkup == null) return;

        BuildPriceGeneratorMarkupsAsync(selectedMarkup);
    }

    private static void BuildPriceGeneratorMarkupsAsync(MarkupGroup group)
    {
        PriceGenerator.MarkUps.Clear();

        foreach (var toUsd in CurrencyConverter.ToUsdDoub)
        {
            var intervalMap = new AdaptiveIntervalMap<MarkupModel>(useExperimental: false, Intersection.CanIntersect);
            double lastRangeEnd = double.NaN;

            foreach (var range in group.MarkupRanges.OrderBy(x => x.RangeStart))
            {
                var rangeStart = double.IsNaN(lastRangeEnd)
                    ? Math.Round(Convert.ToDouble(range.RangeStart), 2)
                    : Math.Round(lastRangeEnd + 0.01, 2);

                var exchangedEnd = (double)range.RangeEnd / CurrencyConverter.ToUsdDoub[group.CurrencyId] * toUsd.Value;
                var rangeEnd = Math.Round(exchangedEnd, 2);
                var markupModel = new MarkupModel(Math.Round(Convert.ToDouble(range.Markup), 2));

                intervalMap.AddInterval(new Interval<MarkupModel>(rangeStart, rangeEnd, markupModel));
                lastRangeEnd = rangeEnd;
            }

            PriceGenerator.MarkUps[toUsd.Key] = intervalMap;
        }
    }
}
