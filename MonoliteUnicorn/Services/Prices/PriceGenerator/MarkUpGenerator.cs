using Microsoft.EntityFrameworkCore;
using MonoliteUnicorn.Exceptions;
using MonoliteUnicorn.PostGres.Main;

namespace MonoliteUnicorn.Services.Prices.PriceGenerator;

public class MarkUpGenerator(DContext context)
{
    private int _defaultCurrencyId;
    public async Task ReCalculateMarkupAsync(CancellationToken cancellationToken = default)
    {
        await ConvertBuySellToDefaultCurrencyAsync(cancellationToken);
        await CalculateNullMarkUpsAsync(cancellationToken);
        await MarkOutLinersAsync(cancellationToken);
        await UpdateMarkUpRangesAsync(cancellationToken);
    }

    private async Task ConvertBuySellToDefaultCurrencyAsync(CancellationToken cancellationToken = default)
    {
        var defaultCurrency = await context.DefaultSettings.AsNoTracking()
            .FirstOrDefaultAsync(x => x.Key == "DefaultCurrency", cancellationToken) ?? throw new DefaultSettingNotFoundException("DefaultCurrency");  
        _defaultCurrencyId = Convert.ToInt32(defaultCurrency.Value);
        var currency = await context.Currencies.AsNoTracking().FirstOrDefaultAsync(x => x.Id == _defaultCurrencyId, cancellationToken)
            ?? throw new ValueNotFoundException("Currency", defaultCurrency.Value);
        var toUsdValues = await context.CurrencyToUsds.AsNoTracking()
            .ToDictionaryAsync(x => x.CurrencyId, cancellationToken);
        await foreach (var val in context.BuySellPrices.Where(x => x.CurrencyId != currency.Id).AsAsyncEnumerable().WithCancellation(cancellationToken))
        {
            var buyToUsd = val.BuyPrice / toUsdValues[val.CurrencyId].ToUsd;
            var sellToUsd = val.SellPrice / toUsdValues[val.CurrencyId].ToUsd;
            var toNeededCurrencyBuy = Math.Round(buyToUsd * toUsdValues[currency.Id].ToUsd, 2);
            var toNeededCurrencySell = Math.Round(sellToUsd * toUsdValues[currency.Id].ToUsd, 2);
            
            val.BuyPrice = toNeededCurrencyBuy;
            val.SellPrice = toNeededCurrencySell;
            val.CurrencyId = currency.Id;
        }
        await context.SaveChangesAsync(cancellationToken);
    }
    private async Task CalculateNullMarkUpsAsync(CancellationToken cancellationToken = default)
    {
        await foreach(var val in context.BuySellPrices.Where(x => x.Markup == null).AsAsyncEnumerable().WithCancellation(cancellationToken))
            val.Markup = Math.Round(((val.SellPrice - val.BuyPrice) / val.BuyPrice) * 100, 2);
        await context.SaveChangesAsync(cancellationToken);
    }

    private async Task UpdateMarkUpRangesAsync(CancellationToken cancellationToken = default)
    {
        context.MarkupGroups.RemoveRange(await context.MarkupGroups
            .Where(x => x.CurrencyId == _defaultCurrencyId && x.IsAutoGenerated)
            .ToListAsync(cancellationToken));
        var newGroup = new MarkupGroup
        {
            CurrencyId = _defaultCurrencyId,
            IsAutoGenerated = true,
            Name = "Auto Generated Markup For Default Currency",
        };
        await context.AddAsync(newGroup, cancellationToken);
        await context.SaveChangesAsync(cancellationToken);
        
        var firstCent = await  context.BuySellPrices.AsNoTracking()
            .Where(x => x.BuyPrice >= 0 && x.BuyPrice <= 0.1m).ToListAsync(cancellationToken);
        if (firstCent.Count > 0)
        {
            var avrg = firstCent.Sum(x => x.Markup)/firstCent.Count;
            var markup = avrg > 50 ? avrg - 10 : avrg;
            await context.MarkupRanges.AddAsync(new MarkupRange
            {
                RangeStart = 0,
                RangeEnd = 0.1m,
                Markup = Math.Round(markup ?? 25, 2),
                Group = newGroup,
            }, cancellationToken);
        }
        var maxBuy = await context.BuySellPrices.OrderByDescending(x => x.BuyPrice)
            .FirstOrDefaultAsync(cancellationToken);
        var maxBuyPrice = maxBuy?.BuyPrice ?? 0;
        decimal step = 1.5m;
        int stopCount = 0;
        for (decimal i = 0.11m;;)
        {
            if(i > maxBuyPrice) break;
            var nextI = Math.Round(i * step, 2);
            var allTill = await context.BuySellPrices.AsNoTracking()
                .Where(x => x.BuyPrice >= i && x.BuyPrice <= nextI && !x.IsOutLiner).ToListAsync(cancellationToken);
            if (allTill.Count == 0)
            {
                i = nextI + 0.01m;
                stopCount++;
                if (stopCount <= 100) continue;
                break;
            }
            var avrg = allTill.Sum(x => x.Markup)/allTill.Count ?? 25;
            var markup = avrg > 50 ? avrg - 10 : avrg;
            await context.MarkupRanges.AddAsync(new MarkupRange
            {
                RangeStart = i,
                RangeEnd = nextI,
                Markup = Math.Round(markup, 2),
                Group = newGroup
            }, cancellationToken);
            i = nextI + 0.01m;
        }
        await context.SaveChangesAsync(cancellationToken);
        var first = await context.MarkupRanges.Where(x => x.GroupId == newGroup.Id)
            .OrderBy(x => x.RangeStart)
            .FirstOrDefaultAsync(cancellationToken);
        var second = await context.MarkupRanges.Where(x => x.GroupId == newGroup.Id)
            .OrderBy(x => x.RangeStart)
            .Skip(1)
            .FirstOrDefaultAsync(cancellationToken);
        if (first != null)
        {
            first.RangeStart = 0;
            if (second != null) first.RangeEnd = second.RangeStart - 0.01m;
        }
        
        await context.SaveChangesAsync(cancellationToken);
    }

    private async Task MarkOutLinersAsync(CancellationToken cancellationToken = default)
    { 
        var maxBuy = await context.BuySellPrices.OrderByDescending(x => x.BuyPrice)
            .FirstOrDefaultAsync(cancellationToken);
        var maxBuyPrice = maxBuy?.BuyPrice ?? 0;
        decimal step = 1.5m;
        int stopCount = 0;
        for (decimal i = 0.11m;;)
        {
            if(i > maxBuyPrice) break;
            var nextI = Math.Round(i * step, 2);
            var allTill = await context.BuySellPrices.Where(x => x.BuyPrice >= i && x.BuyPrice <= nextI)
                .ToListAsync(cancellationToken);
            if (allTill.Count == 0)
            {
                i = nextI + 0.01m;
                stopCount++;
                if (stopCount <= 100) continue;
                break;
            }
            var mean = allTill.Sum(x => x.Markup)/allTill.Count ?? 25;
            var stdDev = Math.Round(Convert.ToDecimal(CalculateStandardDeviation(allTill.Select(x => x.Markup ?? 0).ToList(), mean)), 2);
            var lowerBound = mean - 3 * stdDev;
            var upperBound = mean + 3 * stdDev;
            var data = allTill.Select(x => (x.SaleContentId, x.Markup ?? 0)).ToList();
            var outLiners = FindOutliers(data, lowerBound, upperBound);
            foreach (var outLine in allTill.Where(x => outLiners.Any(z => z.Id == x.SaleContentId)).ToList())
                outLine.IsOutLiner = true;
            
            i = nextI + 0.01m;
        }
        await context.SaveChangesAsync(cancellationToken);
    }
    private static double CalculateStandardDeviation(IEnumerable<decimal> data, decimal mean)
    {
        var dataList = data.ToList();
        double sumOfSquares = 0;
        foreach (var value in dataList)
        {
            var t = value - mean;
            sumOfSquares += Math.Pow(Convert.ToDouble(t), 2);
        }
        
        return Math.Sqrt(sumOfSquares / dataList.Count);
    }
    private static IEnumerable<(int Id, decimal Value)> FindOutliers(IEnumerable<(int Id, decimal MarkUp)> data, decimal lowerBound, decimal upperBound)
    {
        var minimalMarkUp = (decimal)PriceGenerator.MinimalMarkUp;
        return data.Where(value => value.MarkUp < lowerBound || value.MarkUp > upperBound || value.MarkUp <= minimalMarkUp).ToList();
    }
}