using Abstractions.Interfaces.Services;
using Application.Common.Interfaces;
using Application.Common.Interfaces.Settings;
using Attributes;
using Contracts.Markup;
using Mapster;
using MassTransit;
using MediatR;
using Pricing.Abstractions.Dtos.Markups;
using Pricing.Abstractions.Interfaces.DbRepositories;
using Pricing.Entities;

namespace Pricing.Application.Handlers.Markups.SetGeneratedMarkup;

[Transactional]
public record SetGeneratedMarkupCommand(IEnumerable<NewMarkupRangeDto> Ranges, int CurrencyId) : ICommand;

public class SetGeneratedMarkupHandler(IMarkupRepository markupRepository, ISettingsContainer settingsContainer, 
    IUnitOfWork unitOfWork, IPublishEndpoint publishEndpoint) : ICommandHandler<SetGeneratedMarkupCommand>
{
    public async Task<Unit> Handle(SetGeneratedMarkupCommand request, CancellationToken cancellationToken)
    {
        var generatedMarkup = await markupRepository.GetGeneratedMarkupsAsync(cancellationToken: cancellationToken);
        if (generatedMarkup == null)
        {
            generatedMarkup = new MarkupGroup();
            await unitOfWork.AddAsync(generatedMarkup, cancellationToken);
        }

        var setting = settingsContainer.GetSetting(Abstractions.Constants.Settings.Pricing);

        generatedMarkup.CurrencyId = request.CurrencyId;
        generatedMarkup.IsAutoGenerated = true;
        generatedMarkup.Name = "Auto Generated Markup";
        generatedMarkup.MarkupRanges = request.Ranges.Adapt<List<MarkupRange>>();
        
        if (setting.SelectedMarkupId == generatedMarkup.Id)
            await publishEndpoint.Publish(new MarkupGroupChangedEvent { GroupId = generatedMarkup.Id }, cancellationToken);
        
        await unitOfWork.SaveChangesAsync(cancellationToken);
        return Unit.Value;
    }
}